//
//  AbFab01Filter.m
//  AbFab01
//
//  Copyright (c) 2012 John. All rights reserved.
//


/*
 faircompanies.com
 Simple life Manhattan: a 90-square-foot microstudio
 Airstream-inspired apartments as affordable tiny homes
 325-square-foot cave apartment has DIY & upcycled furniture
 NYC "Swiss Army knife" apartment's walls open, fold & slide
 Lego-style apartment transforms into infinite spaces
 House in a suitcase: tiny home + 2 trunks of furniture
 Passive solar, urban livework, relatively small space design
 Space-saving furniture that transforms 1 room into 2 or 3
 http://www.resourcefurniture.com
 
 Amaranth: a superfood for the backyard gardener
 */

/*
 The reader (a person using the plug-in) will create 5 concentric regions of interest (ROI), like a Babushka doll, across layers within a 10mm abdominal slab between L4 and L5.
 ROI1 = first region of interest from the outside, the epidermis
 ROI2 = next region of interest within ROI1
 ROI3 = next region of interst within ROI2
 ROI4 = next region of interest within ROI3
 ROI5 = next region of interest within ROI4
 
 ROI1 can be automatically generated by finding the edge of the image, but it must be seeded with a point between L4 and L5:  "Point 1".
 
 When the plug-in runs:
 
 1) look for ROI named "Point 1"
 if "Point 1" ROI not found, then present user with 3D Viewer > Orthogonal 2D MPR (for current image) = [viewerController orthogonalMPRViewer:[viewerController imageView]]
 
 2) look for ROIs named "ROI1" (epidermal) on all slices relative to "Point 1"
 if not found, then run ROI > Grow Region (2D/3D Segmentation...) = "regionGrowing3D" relative to "Point 1" (generate "ROI1" on all slices relative to "Point 1")
 ITKSegmentation3D class, regionGrowing3D method
 (hint: use "segmentation" as a search word to find related class method
 2D Growing Region (current image only)
 Threshold (lower/upper bounds)
 Lower Threshold = -190
 Upper Threshold = 800
 Create ROI(s) in the original series
 Polygon
 # of point = High
 ROI name: "Epidermis"
 
 prompt user to create ROI2 - ROI5 on all slices relative to "Point 1"
 
 3) look for ROIs named "ROI2", "ROI3", "ROI4", "ROI5" (inner most) on all slices relative to "Point 1"
 if any one ROI series has less than three ROIs, prompt user to create at least three ROIs for that series
 if any one ROI series is incomplete, but has at least three or more, then generate missing ROIs
 
 4) calculate statistics on all ROIs, allow user selected save location, remember last location saved (via userDefault)
 
 
 */


/*	https://osirixpluginbasics.wordpress.com/2010/11/05/brush-roi-tplain/
 1. Creation of a brush ROI
 
 All you need to create a brush roi are the coordinates of the pixel you like to include.
 At first just a small excursus to the memory organisation of images in OsiriX. Every image consists of pixel. These pixels have somehow to be saved in RAM. The first method is using a two-dimensional array so you can access the pixel with:
 pixel[x, y]
 
 This method comes natural and is easy to understand. The second method only uses a one-dimensional array. Imagine all rows of pixels put after another. The pixel can be accessed this way:
 pixel[y * ImageWidth + x]
 
 OsiriX uses the second method, so you better get familiar with this!
 Now we (hopefully) know how the images are saved in memory. For creating a brush roi we have to create an empty array the same size as the current image. In this array we have to �mark� the pixel we like to include. This is already the hardest part. The rest can be left to OsiriX functions and procedures already included. No additional coding needed.
 The following source code creates a brush ROI, where every pixel with a value below �ThresholdValue� will be added to the ROI.
 
 
 NSArray	*pixList = [viewerController pixList: 0];
 int		curSlice = [[viewerController imageView] curImage];
 DCMPix		*curPix = [pixList objectAtIndex: curSlice];
 
 ROI		*theNewROI;
 float		PixHeight = [curPix pheight];
 float		PixWidth = [curPix pwidth];
 float		SumOfPixel = PixWidth * PixHeight;
 
 unsigned char	*textureBuffer;
 
 // create array with the same size as the current image
 textureBuffer = (unsigned char*)malloc(SumOfPixel*sizeof(unsigned char));
 
 // iterate through every pixel and initialize it
 for (x=0; x< SumOfPixel; x++) textureBuffer[x] = 0x00;
 
 // iterate through every pixel and set the pixels you like to include to "0xFF"
 for (x=0; x< SumOfPixel; x++)
 {
 if (fImageA[x] <= ThresholdValue)
 {
 textureBuffer[x] = 0xFF;
 }
 }
 
 // our new ROI is actually created
 theNewROI = [[[ROI alloc] initWithTexture:textureBuffer
 textWidth:PixWidth textHeight:PixHeight
 textName:@"Name for our ROI" positionX:0 positionY:0
 spacingX:[curPix pixelSpacingX]  spacingY:[curPix pixelSpacingY]
 imageOrigin:NSMakePoint( [curPix originX], [curPix originY])] autorelease];
 
 // don't forget to free your memory !!!
 free(textureBuffer);
 
 // add the new ROI to the ROI list of the current image
 NSMutableArray	*roiSeriesList = [viewerController roiList];
 int			curSlice = [[viewerController imageView] curImage];
 NSMutableArray	*roiImageList = [roiSeriesList objectAtIndex: curSlice];
 
 [roiImageList addObject: theNewROI];
 
 // We modified the view: OsiriX please update the display!
 [viewerController needsDisplayUpdate];
 
 
 .
 .
 .
 
 3. Which pixel belong to our ROI?
 
 The last thing still missing is the ability to find out which pixel belong to our ROI. In this small piece of code I will get all points inside the ROI and change the pixel values on these pixel to 1000.
 You might wonder if there is no easier way to fill a ROI. Actually there is:
 
 [curPix fillROI:MyROI :FillValue :-99999 :99999 :NO];
 
 
 float	FillValue = 1000;
 
 NSArray	*pixList = [viewerController pixList: 0];
 int		curSlice = [[viewerController imageView] curImage];
 DCMPix		*curPix = [pixList objectAtIndex: curSlice];
 
 long		noOfValues; // number of x,y-coordinates
 float		*theVal; // pointer to where the x,y-coordinates are saved
 int		x,y; // coordinate
 float		*fImageA = [curPix fImage]; // load the pixels of the current image
 
 // load all x,y-coordinates of "MyROI"
 [curPix getROIValue: &noOfValues :MyROI :&theVal];
 
 for (i = 0; i < noOfValues; i++)
 {
 // get x,y-coordinate for pixel number "i" in ROI
 x = theVal[2*i];
 y = theVal[2*i+1];
 
 // set pixel value at this point to 1000
 fImageA[ [curPix pheight] * y + x] = FillValue;
 }
 
 // never forget to free the memory
 free(theVal);
 
 // We modified the view: OsiriX please update the display!
 [viewerController needsDisplayUpdate];
 
 */

#import "AbFab01Filter.h"

#import "DCMObject.h"
#import "DCMAttribute.h"
#import "DCMAttributeTag.h"
#import "ITKSegmentation3D.h"

@implementation AbFab01Filter

@synthesize dictMetaData;

- (void) initPlugin
{
	//	NSUserDefaults *preferences = [NSUserDefaults standardUserDefaults];
	//	[preferences removeObjectForKey:@"OsiriXPluginRootDirectory"];
	//	[preferences synchronize]; //at the end of storage
	
	if ( [[[NSUserDefaultsController sharedUserDefaultsController] values] valueForKey:@"OsiriXPluginRootDirectory"] == nil )
	{
		NSUserDefaults *preferences = [NSUserDefaults standardUserDefaults];
		[preferences setObject:[[NSURL fileURLWithPath:NSHomeDirectory() isDirectory:TRUE] absoluteString] forKey:@"OsiriXPluginRootDirectory"];
		[preferences synchronize]; //at the end of storage
	}
}


- (void)awakeFromNib
{
}


- (long) filterImage:(NSString*) menuName
{
	// [viewerController orthogonalMPRViewer:[viewerController imageView] ] ;  // 3D Viewer > Orthogonal 2D MPR (for current image)
	
	
	
	
	// - (void) regionGrowing3D:(ViewerController*) srcViewer :(ViewerController*) destViewer :(long) slice :(NSPoint) startingPoint :(int) algorithmNumber :(NSArray*) parameters :(BOOL) setIn :(float) inValue :(BOOL) setOut :(float) outValue :(int) roiType :(long) roiResolution :(NSString*) newname :(BOOL) mergeWithExistingROIs;
	/*
	 - (void) regionGrowing3D	:(ViewerController*) srcViewer
	 :(ViewerController*) destViewer
	 :(long) slice
	 :(NSPoint) startingPoint
	 :(int) algorithmNumber
	 :(NSArray*) parameters
	 :(BOOL) setIn
	 :(float) inValue
	 :(BOOL) setOut
	 :(float) outValue
	 :(int) roiType
	 :(long) roiResolution
	 :(NSString*) newname
	 :(BOOL) mergeWithExistingROIs;
	 */
	// NSPoint aPoint = NSMakePoint(261.243, 297.921);
	
	// ITKSegmentation3D	*itk = [[ITKSegmentation3D alloc] initWith:[viewer pixList] :[viewer volumePtr] :slice];
	ITKSegmentation3D	*itk = [[ITKSegmentation3D alloc] initWith:[viewerController pixList] :[viewerController volumePtr] :[[viewerController imageView] curImage]];
	
	NSPoint aPoint = { 261.243, 297.921 };
	
	NSMutableArray *parametersArray = [NSMutableArray arrayWithCapacity:1];
	[parametersArray addObject:[NSNumber numberWithFloat:-190]];
	[parametersArray addObject:[NSNumber numberWithFloat:800]];
	
	[itk regionGrowing3D:viewerController  //srcViewr
						:nil		// destViewer
						:[[viewerController imageView] curImage]  // slice
						:aPoint	//startingPoint
						:1			// algorithmNumber
						:parametersArray  // parameters
						:NO		// setIn
						:0			// inValue
						:NO		// setOut
						:0			// outValue
						:1			// roiType
						:1			// roiResolution
						:@"ROI1"	// newname
						:NO		// mergeWithExistingROIs
	 ];
	
	[itk release];
	
	// [viewerController orthogonalMPRViewer:[viewerController imageView] ] ;  // 3D Viewer > Orthogonal 2D MPR (for current image)
	
	return 0;
	
	
	
	// need to find code for regionGrowing3D, create separate plug-in
	
	dictMetaData = [NSMutableDictionary dictionaryWithObjectsAndKeys:
					@"Analyst", @"Analyst",
					[self getDCMValue:@"SliceThickness"], @"SliceThickness",
					@"Analyst Date", @"AnalystDate",
					[self getDCMValue:@"PatientID"], @"PatientID",
					
					[self getDCMValue:@"StudyID"], @"StudyID",
					[self getDCMValue:@"SeriesNumber"], @"SeriesNumber",
					[self getDCMValue:@"SOPInstanceUID"], @"SOPInstanceUID",
					[self getDCMValue:@"StudyDate"], @"StudyDate",
					
					[self getDCMValue:@"Modality"], @"Modality",
					[self getDCMValue:@"SoftwareVersions"], @"SoftwareVersions",
					
					@"VOIName", @"VOIName",
					
					@"0", @"roiVol",
					@"0", @"TotalMean",
					@"0", @"TotalSTD",
					@"0", @"TotalMin",
					@"0", @"TotalMax",
					
					@"0", @"FatVol",
					@"0", @"FatMean",
					@"0", @"FatSTD",
					@"0", @"FatMin",
					@"0", @"FatMax",
					
					@"0", @"MuscleVol",
					@"0", @"MuscleMean",
					@"0", @"MuscleSTD",
					@"0", @"MuscleMin",
					@"0", @"MuscleMax",
					
					@"white", @"VOIColor",
					
					@"0", @"userFirstSlice",
					@"0", @"userLastSlice",
					@"-190", @"FatThresholdFrom",
					@"-30", @"FatThresholdTo",
					@"-30", @"MuscleThresholdFrom",
					@"160", @"MuscleThresholdTo",
					nil];
	
	DCMPix			*curPix;
	ROI				*curROI;
	ROI				*totalROI;
	long			noOfValues;  // number of x,y-coordinates
	float			*theVal;  // pointer to where the x,y-coordinates are saved
	float			*fImageA;
	NSMutableArray	*arrayROIPoints = nil;
	NSMutableArray	*generatedROIs = nil;
	NSString		*stringVolumeError;
	
	unsigned char	*textureBufferFat;
	ROI				*roiFat;
	
	unsigned char	*textureBufferMuscle;
	ROI				*roiMuscle;
	
	bool			isLastSliceFound = NO;
	
	NSPoint pointOne;
	
	NSMutableArray *arrayFImageATotal	= [NSMutableArray arrayWithCapacity:1];  // use this to collect the float values from fImageA for each slice with a ROI
	NSMutableArray *arrayFImageAFat		= [NSMutableArray arrayWithCapacity:1];  // use this to collect the float values from fImageAFat for each slice with a ROI
	NSMutableArray *arrayFImageAMuscle	= [NSMutableArray arrayWithCapacity:1];  // use this to collect the float values from fImageAMuscle for each slice with a ROI
	
	NSNumberFormatter *numberFormatter = [[[NSNumberFormatter alloc] init] autorelease];
	[numberFormatter setFormat:@"#,##0.###### ;0 ;#,##0.###### "];
	
	
    for( NSMutableArray *roiSlice in [viewerController roiList] )
    {
		if ( [roiSlice count] > 0 )
		{
			int imageNumber = [[viewerController roiList] count] - [ [viewerController roiList] indexOfObject:roiSlice ];
			if ( isLastSliceFound == NO )
			{
				isLastSliceFound = YES;
				[dictMetaData setObject:[NSNumber numberWithInt:imageNumber] forKey:@"lastSlice"];
			}
			else
			{
				[dictMetaData setObject:[NSNumber numberWithInt:imageNumber] forKey:@"firstSlice"];
			}
			
			for ( curROI in roiSlice )
			{
				if ( [[curROI name] isEqualToString:@"Point 1"] )
				{
					// do nothing, we don't want to process the "Point 1" ROI
					// get NSPoint for "Point 1", used to find ROI1
					pointOne = [curROI imageOrigin];
				}
				else
				{
					curPix = [[viewerController pixList] objectAtIndex:[ [viewerController roiList] indexOfObject:roiSlice ]];
					fImageA = [curPix fImage];  // load the pixels of the current image
					textureBufferFat = (unsigned char*)malloc( ([curPix pwidth] * [curPix pheight]) * sizeof(unsigned char));  // create array with the same size as the current image
					textureBufferMuscle = (unsigned char*)malloc( ([curPix pwidth] * [curPix pheight]) * sizeof(unsigned char));  // create array with the same size as the current image
					
					
					
					// iterate through every pixel in the image buffer and initialize it to "0x00"
					for (int i=0; i < ([curPix pwidth] * [curPix pheight]); i++)
					{
						textureBufferFat[i] = 0x00;
						textureBufferMuscle[i] = 0x00;
					}
					
					// load all x,y-coordinates of current ROI, this is what Caresse (reader) outlined
					[curPix getROIValue: &noOfValues :curROI :&theVal];
					
					// iterate through every pixel in ROI and set the pixels you like to include to "0xFF"
					// check if pixel is within fat range of -190 to -30, muscle range = -30 to 160
					for (int i = 0; i < noOfValues; i++)
					{
						// get x,y-coordinate for pixel number "i" in ROI
						int x = theVal[2*i];
						int y = theVal[2*i+1];
						
						if ( fImageA[[curPix pheight] * y + x] >= -190 && fImageA[[curPix pheight] * y + x] <= -30 )
						{
							textureBufferFat[ y * [curPix pwidth] + x ] = 0xFF;
							[arrayFImageAFat addObject:[NSNumber numberWithFloat:fImageA[[curPix pheight] * y + x] ] ];
						}
						if ( fImageA[[curPix pheight] * y + x] >   -30 && fImageA[[curPix pheight] * y + x] <= 160 )
						{
							textureBufferMuscle[ y * [curPix pwidth] + x ] = 0xFF;
							[arrayFImageAMuscle addObject:[NSNumber numberWithFloat:fImageA[[curPix pheight] * y + x] ] ];
						}
						
						[arrayFImageATotal addObject:[NSNumber numberWithFloat:fImageA[[curPix pheight] * y + x] ] ];
					}
					
					totalROI = curROI;
					
					// our new ROI is actually created
					roiFat = [[[ROI alloc] initWithTexture:textureBufferFat
												 textWidth:[curPix pwidth] textHeight:[curPix pheight]
												  textName:@"roiFat" positionX:0 positionY:0
												  spacingX:[curPix pixelSpacingX]  spacingY:[curPix pixelSpacingY]
											   imageOrigin:NSMakePoint( [curPix originX], [curPix originY])] autorelease];
					// don't forget to free your memory !!!
					free(textureBufferFat);
					// add the new ROI to the ROI list of the current image
					[roiFat setColor:(RGBColor){65535,65535,0} ];
					[roiSlice addObject: roiFat];
					
					
					// our new ROI is actually created
					roiMuscle = [[[ROI alloc] initWithTexture:textureBufferMuscle
													textWidth:[curPix pwidth] textHeight:[curPix pheight]
													 textName:@"roiMuscle" positionX:0 positionY:0
													 spacingX:[curPix pixelSpacingX]  spacingY:[curPix pixelSpacingY]
												  imageOrigin:NSMakePoint( [curPix originX], [curPix originY])] autorelease];
					// don't forget to free your memory !!!
					free(textureBufferMuscle);
					// add the new ROI to the ROI list of the current image
					[roiMuscle setColor:(RGBColor){65535,0,0} ];
					[roiSlice addObject: roiMuscle];
				}
			}
		}
    }
	
	// We modified the view: OsiriX please update the display!
	[viewerController needsDisplayUpdate];
	
	
	arrayROIPoints = [totalROI points];
	[dictMetaData setObject:[NSNumber numberWithFloat:[viewerController computeVolume:totalROI	points:&arrayROIPoints generateMissingROIs:TRUE generatedROIs:generatedROIs computeData:nil error:&stringVolumeError] ] forKey:@"roiVol"];
	[dictMetaData setObject:[self getFunction:@"average:"	:arrayFImageATotal] forKey:@"TotalMean"];
	[dictMetaData setObject:[self getFunction:@"stddev:"	:arrayFImageATotal] forKey:@"TotalSTD"];
	[dictMetaData setObject:[self getFunction:@"min:"		:arrayFImageATotal] forKey:@"TotalMin"];
	[dictMetaData setObject:[self getFunction:@"max:"		:arrayFImageATotal] forKey:@"TotalMax"];
	
	arrayROIPoints = [roiFat points];
	[dictMetaData setObject:[NSNumber numberWithFloat:[viewerController computeVolume:roiFat	points:&arrayROIPoints generateMissingROIs:TRUE generatedROIs:generatedROIs computeData:nil error:&stringVolumeError] ] forKey:@"FatVol"];
	[dictMetaData setObject:[self getFunction:@"average:"	:arrayFImageAFat] forKey:@"FatMean"];
	[dictMetaData setObject:[self getFunction:@"stddev:"	:arrayFImageAFat] forKey:@"FatSTD"];
	[dictMetaData setObject:[self getFunction:@"min:"		:arrayFImageAFat] forKey:@"FatMin"];
	[dictMetaData setObject:[self getFunction:@"max:"		:arrayFImageAFat] forKey:@"FatMax"];
	
	arrayROIPoints = [roiMuscle points];
	[dictMetaData setObject:[NSNumber numberWithFloat:[viewerController computeVolume:roiMuscle	points:&arrayROIPoints generateMissingROIs:TRUE generatedROIs:generatedROIs computeData:nil error:&stringVolumeError] ] forKey:@"MuscleVol"];
	[dictMetaData setObject:[self getFunction:@"average:"	:arrayFImageAMuscle] forKey:@"MuscleMean"];
	[dictMetaData setObject:[self getFunction:@"stddev:"	:arrayFImageAMuscle] forKey:@"MuscleSTD"];
	[dictMetaData setObject:[self getFunction:@"min:"		:arrayFImageAMuscle] forKey:@"MuscleMin"];
	[dictMetaData setObject:[self getFunction:@"max:"		:arrayFImageAMuscle] forKey:@"MuscleMax"];
	
	
	
	
	
	
	
	
	
	
	
	//	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=	=
	
	
	// NSRunInformationalAlertPanel(@"filterImage", [dictMetaData description],  @"OK", 0L, 0L);
	NSRunInformationalAlertPanel(@"filterImage",
								 [NSString stringWithFormat:
								  @"Analyst = %@"
								  "\nSliceThickness = %@"
								  "\nAnalystDate = %@"
								  "\nPatientID = %@"
								  "\nStudyID = %@"
								  "\nSeriesNumber = %@"
								  "\nSOPInstanceUID = %@"
								  "\nStudyDate = %@"
								  "\nModality = %@"
								  "\nSoftwareVersions = %@"
								  
								  "\n\nVOI_name"
								  
								  "\tTotal_vol(cm^3)"
								  "\tTotal_mean"
								  "\tTotal_std"
								  "\tTotal_min"
								  "\tTotal_max"
								  
								  "\tFat_vol(cm^3)"
								  "\tFat_mean"
								  "\tFat_std"
								  "\tFat_min"
								  "\tFat_max"
								  
								  "\tMus_vol(cm^3)"
								  "\tMus_mean"
								  "\tMus_std"
								  "\tMus_min"
								  "\tMus_max"
								  
								  "\tVOI_color"
								  
								  "\n%@"
								  
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  "\t%@"
								  
								  "\t%@"
								  
								  "\nStartSliceNumber = %@"
								  "\nEndSliceNumber = %@"
								  "\nFatThresholdFrom = %@"
								  "\nFatThresholdTo = %@"
								  "\nMuscleThresholdFrom = %@"
								  "\nMuscleThresholdTo = %@"
								  "\n\nOsiriXPluginRootDirectory = %@"
								  ,
								  
								  [dictMetaData objectForKey:@"Analyst"],
								  [dictMetaData objectForKey:@"SliceThickness"],
								  [dictMetaData objectForKey:@"AnalystDate"],
								  [dictMetaData objectForKey:@"PatientID"],
								  [dictMetaData objectForKey:@"StudyID"],
								  [dictMetaData objectForKey:@"SeriesNumber"],
								  [dictMetaData objectForKey:@"SOPInstanceUID"],
								  [dictMetaData objectForKey:@"StudyDate"],
								  [dictMetaData objectForKey:@"Modality"],
								  [dictMetaData objectForKey:@"SoftwareVersions"],
								  
								  [dictMetaData objectForKey:@"VOIName"],
								  
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"roiVol"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"TotalMean"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"TotalSTD"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"TotalMin"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"TotalMax"]],
								  
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"FatVol"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"FatMean"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"FatSTD"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"FatMin"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"FatMax"]],
								  
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"MuscleVol"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"MuscleMean"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"MuscleSTD"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"MuscleMin"]],
								  [numberFormatter stringFromNumber:[dictMetaData objectForKey:@"MuscleMax"]],
								  
								  [dictMetaData objectForKey:@"VOIColor"],
								  
								  [dictMetaData objectForKey:@"firstSlice"],
								  [dictMetaData objectForKey:@"lastSlice"],
								  [dictMetaData objectForKey:@"FatThresholdFrom"],
								  [dictMetaData objectForKey:@"FatThresholdTo"],
								  [dictMetaData objectForKey:@"MuscleThresholdFrom"],
								  [dictMetaData objectForKey:@"MuscleThresholdTo"],
								  [[[NSUserDefaultsController sharedUserDefaultsController] values] valueForKey:@"OsiriXPluginRootDirectory"]
								  ],
								 @"OK", 0L, 0L);
	
	return 0; // no errors
	
	// return -1  // errors
    
}


-(NSString*)getDCMValue:(NSString *)aTagName
{
	NSArray			*pixList = [viewerController pixList: 0];
	long			curSlice = [[viewerController imageView] curImage];
	DCMPix			*curPix = [pixList objectAtIndex: curSlice];
	
	return [[[[DCMObject objectWithContentsOfFile:[curPix sourceFile] decodingPixelData:NO] attributeForTag:[DCMAttributeTag tagWithName:aTagName]] value] description];
}



- (id) getFunction:(NSString *)anExpressionForFunction :(NSArray *)anExpressionForConstantValue
{
	NSExpression *arrayExpression	= [NSExpression expressionForConstantValue:anExpressionForConstantValue];
	NSArray *argumentArray			= [NSArray arrayWithObject:arrayExpression];
	NSExpression *expression		= [NSExpression expressionForFunction:anExpressionForFunction arguments:argumentArray];
	
	return [expression expressionValueWithObject: nil context: nil];
}

@end
